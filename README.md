# Вопросы для интервью по базам данных и SQL

## Тема 1: Общие понятия баз данных (БД)

### Простой уровень

1.  **Что такое база данных (БД)?**
    *   **q:** Дай простое и понятное определение базы данных. С чем ее можно сравнить в реальной жизни?
    *   **a:**
        *   **Кратко:** Это структурированное хранилище информации.
        *   **Подробно:** База данных — это организованная совокупность данных, хранящихся и обрабатываемых в электронном виде. Проще говоря, это место, где хранится информация. В реальной жизни аналогом может служить тетрадка со списком покупок, картотека в библиотеке или папка с файлами на компьютере, но в цифровом мире данные в БД структурированы так, чтобы к ним можно было быстро получить доступ, управлять ими и обновлять их.

2.  **Для чего нужны базы данных?**
    *   **q:** Назови основные причины, по которым мы используем базы данных, а не просто храним информацию в текстовых файлах.
    *   **a:**
        *   **Кратко:** Для хранения, управления и быстрого доступа к информации.
        *   **Подробно:** Базы данных нужны, чтобы эффективно хранить большие объемы информации, быстро ее искать и получать по запросу, управлять доступом (кто что может видеть и менять), обеспечивать целостность (непротиворечивость) данных и избегать хаоса. Без них невозможно представить работу современных сайтов, приложений и сервисов, так как они являются "мозгом" любой информационной системы.

3.  **Что такое СУБД? Чем она отличается от базы данных?**
    *   **q:** Объясни разницу между понятиями "база данных" и "система управления базами данных". Это одно и то же?
    *   **a:**
        *   **Кратко:** СУБД — это программа для управления БД. БД — это сами данные.
        *   **Подробно:** База данных — это хранилище информации (например, сами таблицы с данными о пользователях). А СУБД (Система управления базами данных) — это комплекс программных средств, который позволяет создавать эти базы, управлять данными (добавлять, изменять, удалять), обрабатывать запросы и обеспечивать безопасность. Пример: MySQL — это СУБД, а все таблицы с данными, которыми она управляет, составляют базу данных.

4.  **Какие два основных типа баз данных существуют?**
    *   **q:** Назови две большие категории, на которые делятся все современные базы данных.
    *   **a:**
        *   **Кратко:** Реляционные и нереляционные (NoSQL).
        *   **Подробно:** Основное деление баз данных проходит по способу организации данных. Реляционные базы данных хранят информацию в виде связанных таблиц. Нереляционные (или NoSQL) базы данных используют другие модели хранения: документы, графы, пары "ключ-значение" и так далее, и обычно не требуют жесткой схемы данных.

5.  **Что такое реляционная база данных?**
    *   **q:** Опиши, как организованы данные в реляционной базе данных. В каком виде они там находятся?
    *   **a:**
        *   **Кратко:** Это БД, где данные хранятся в виде связанных между собой таблиц.
        *   **Подробно:** Реляционная база данных основана на табличной модели. Информация разбита на двумерные таблицы, состоящие из строк (записей) и столбцов (полей). Между таблицами можно устанавливать связи через специальные ключи, что позволяет эффективно организовывать данные и избегать их дублирования. Термин "реляционная" происходит от слова relation (отношение), что является математическим синонимом таблицы.

6.  **Что такое таблица в базе данных? Из чего она состоит?**
    *   **q:** Опиши структуру таблицы в реляционной БД.
    *   **a:**
        *   **Кратко:** Таблица — это структура для хранения данных, состоящая из строк и столбцов.
        *   **Подробно:** Таблицу можно представить как обычный лист Excel. Столбцы (или поля) определяют тип хранимой информации, например, "Имя", "Возраст" или "Email". Каждый столбец имеет имя и тип данных (число, текст, дата). Строки (или записи) содержат конкретные данные об одном объекте, например, информацию об одном конкретном пользователе: его имя, возраст и email.

7.  **Что такое строка (запись) в таблице?**
    *   **q:** Если таблица — это список всех студентов, то что будет являться строкой?
    *   **a:**
        *   **Кратко:** Это информация об одном конкретном объекте.
        *   **Подробно:** Строка, также называемая записью или кортежем, представляет собой набор связанных данных, описывающих один экземпляр сущности. Например, в таблице "Студенты" одна строка будет содержать все данные об одном конкретном студенте: его идентификатор, имя, фамилию, год рождения и так далее.

8.  **Что такое столбец (поле) в таблице?**
    *   **q:** Если строка — это один студент, то что будет являться столбцом?
    *   **a:**
        *   **Кратко:** Это характеристика или атрибут объекта.
        *   **Подробно:** Столбец, или поле, определяет один конкретный атрибут для всех объектов в таблице. Например, столбец "Имя" будет содержать имена всех студентов. Все значения в одном столбце имеют один и тот же тип данных (например, текст или число).

9.  **Назовите пару примеров популярных реляционных СУБД.**
    *   **q:** Приведи 2-3 примера программ, которые являются реляционными СУБД.
    *   **a:**
        *   **Кратко:** MySQL, PostgreSQL, SQLite.
        *   **Подробно:** Существует много популярных реляционных СУБД. Вот некоторые из них:
            *   **MySQL:** Одна из самых популярных открытых СУБД, часто используется в веб-разработке.
            *   **PostgreSQL:** Мощная открытая СУБД с широкими возможностями, поддерживающая сложные запросы.
            *   **SQLite:** Легкая встраиваемая СУБД, которая хранит всю базу в одном файле. Часто используется в мобильных приложениях и для локального хранения данных в программах.
            *   **Oracle Database:** Мощная коммерческая СУБД, часто используемая в крупных корпорациях.

10. **Зачем тестировщику нужно знать основы баз данных?**
    *   **q:** Почему знание баз данных является важным навыком для тестировщика? Где это может пригодиться в работе?
    *   **a:**
        *   **Кратко:** Чтобы проверять, правильно ли сохраняются данные, искать причины ошибок и создавать тестовые данные.
        *   **Подробно:** Знание основ БД помогает тестировщику во многих аспектах работы:
            *   **Проверка данных:** Убедиться, что после оформления заказа запись о нем действительно появилась в базе данных с правильными параметрами.
            *   **Поиск причин багов:** Если на сайте не отображается какой-то товар, причина может быть в отсутствии или неправильном статусе этого товара в БД.
            *   **Проверка бизнес-логики:** Проверить, что в акции участвуют только пользователи старше 18 лет, напрямую посмотрев их возраст в базе.
            *   **Создание тестовых данных:** Быстро подготовить нужные данные для теста (например, создать пользователя с определенными характеристиками) через SQL-запрос, а не через пользовательский интерфейс.
            *   **API-тестирование:** Проверить, что запросы к API корректно изменяют данные в базе.
            *   **Автоматизация:** В автотестах можно сравнивать данные, полученные из БД, с ожидаемыми результатами.

### Средний уровень

11. **Что такое первичный ключ (Primary Key)? Какими свойствами он обладает?**
    *   **q:** Что такое Primary Key в таблице базы данных и какими двумя главными свойствами он должен обладать?
    *   **a:**
        *   **Кратко:** Уникальный идентификатор каждой записи. Должен быть уникальным и не пустым.
        *   **Подробно:** Первичный ключ — это столбец (или набор столбцов), который уникально идентифицирует каждую строку в таблице. Представь его как номер паспорта или идентификационный номер. Благодаря ему мы можем гарантированно обратиться к нужной записи. У него есть два обязательных свойства:
            1.  **Уникальность (UNIQUE):** Значения в столбце первичного ключа не могут повторяться. В таблице не может быть двух разных строк с одинаковым ID.
            2.  **Непустота (NOT NULL):** Поле первичного ключа всегда должно содержать значение. Оно не может быть пустым (NULL).

12. **Что такое внешний ключ (Foreign Key)? Для чего он используется?**
    *   **q:** Объясни, что такое внешний ключ и какую роль он играет во взаимосвязи таблиц.
    *   **a:**
        *   **Кратко:** Это поле в таблице, которое ссылается на первичный ключ другой таблицы для создания связей.
        *   **Подробно:** Внешний ключ — это столбец (или несколько столбцов) в дочерней таблице, который ссылается на первичный ключ родительской таблицы. Он служит "мостиком" для установления связи между двумя таблицами. Например, в таблице "Заказы" может быть столбец `user_id`, который является внешним ключом и ссылается на столбец `id` в таблице "Пользователи". Это позволяет для каждого заказа понять, какому пользователю он принадлежит. Внешний ключ также помогает поддерживать целостность данных: мы не сможем создать заказ для несуществующего пользователя.

13. **Какие типы связей между таблицами вы знаете?**
    *   **q:** Назови основные виды отношений (связей), которые могут существовать между таблицами в реляционной базе данных.
    *   **a:**
        *   **Кратко:** Один-к-одному, один-ко-многим, многие-ко-многим.
        *   **Подробно:**
            *   **Один-к-одному (1:1):** Одной записи в первой таблице соответствует ровно одна запись во второй. Используется редко, например, для расширения таблицы с пользователями дополнительной информацией.
            *   **Один-ко-многим (1:M):** Самый распространенный тип. Одной записи в первой таблице (например, "Категории товаров") может соответствовать много записей во второй (например, "Товары"). При этом каждая запись из второй таблицы принадлежит только одной записи из первой. Реализуется через внешний ключ в "дочерней" таблице.
            *   **Многие-ко-многим (M:N):** Множеству записей в первой таблице соответствует множество записей во второй. Пример: студенты и курсы (один студент может учиться на многих курсах, и на один курс может быть записано много студентов). Такая связь реализуется через третью, промежуточную таблицу.

14. **В чем основная разница между реляционными и нереляционными базами данных?**
    *   **q:** Сравни реляционные и нереляционные БД по принципу организации данных и структуре.
    *   **a:**
        *   **Кратко:** В реляционных — строгая структура таблиц и связи, в нереляционных — гибкая схема и разные форматы хранения.
        *   **Подробно:** Главное различие — в подходе к организации данных. Реляционные БД требуют предопределенной схемы: вы должны четко знать, какие столбцы и какого типа будут в таблицах, прежде чем начать хранить данные. Данные строго структурированы и разбиты на связанные таблицы. Нереляционные БД (NoSQL) предлагают гибкость: они могут хранить данные в формате документов JSON, графов или пар "ключ-значение", и структура данных может меняться от записи к записи. Это делает их удобными для определенных задач, где важна скорость и масштабируемость, а структура данных нестабильна.

15. **Какие типы нереляционных баз данных вы знаете?**
    *   **q:** Перечисли основные виды NoSQL баз данных.
    *   **a:**
        *   **Кратко:** Документо-ориентированные, Key-Value, Графовые, Колоночные.
        *   **Подробно:**
            *   **Документо-ориентированные:** Хранят данные в виде документов (JSON, BSON, XML). Каждый документ самодостаточен и может иметь свою структуру (MongoDB).
            *   **Ключ-значение (Key-Value):** Простейший тип, где данные хранятся как пары "уникальный ключ" и "значение" (Redis, Memcached).
            *   **Графовые:** Данные представлены узлами (сущности) и связями между ними. Идеальны для анализа связей, как в социальных сетях (Neo4j).
            *   **Колоночные (Column-family):** Данные хранятся в столбцах, а не в строках. Оптимизированы для аналитических запросов над огромными объемами данных (Apache Cassandra, HBase).

16. **Для каких задач лучше подходят документо-ориентированные БД (например, MongoDB)?**
    *   **q:** Приведи пример сценария, где использование MongoDB или подобной БД будет предпочтительнее, чем реляционной.
    *   **a:**
        *   **Кратко:** Для хранения данных со сложной, изменяющейся структурой, например, JSON-документов, каталогов товаров, блогов.
        *   **Подробно:** Документо-ориентированные БД отлично подходят для задач, где структура данных может эволюционировать, и где удобно хранить связанные данные вместе, а не разносить по разным таблицам. Например, каталог товаров в интернет-магазине: у разных типов товаров (ноутбуки, книги, одежда) могут быть совершенно разные наборы характеристик. В документной БД мы можем хранить каждый товар как отдельный JSON-документ со своим уникальным набором полей, что очень гибко и удобно.

17. **Что такое индекс в базе данных и для чего он нужен?**
    *   **q:** Объясни, что такое индекс в базе данных. С каким реальным объектом его можно сравнить?
    *   **a:**
        *   **Кратко:** Структура, ускоряющая поиск и выборку данных (как алфавитный указатель в книге).
        *   **Подробно:** Индекс — это специальный объект базы данных, который создается для ускорения операций поиска и выборки данных (`SELECT`). Его можно сравнить с алфавитным указателем в конце книги: чтобы найти все страницы, где упоминается конкретный термин, вы смотрите в указатель, а не листаете всю книгу целиком. Индекс хранит значения из определенного столбца (или столбцов) и указатели на соответствующие строки в таблице. Это позволяет СУБД быстро находить нужные строки без полного сканирования всей таблицы. Однако индексы замедляют операции вставки, обновления и удаления, так как их тоже нужно обновлять.

18. **Какие основные функции выполняет СУБД?**
    *   **q:** Перечисли ключевые задачи, которые решает Система управления базами данных.
    *   **a:**
        *   **Кратко:** Создание БД, управление данными, обеспечение доступа и безопасности.
        *   **Подробно:** СУБД выполняет целый комплекс функций:
            *   **Управление данными:** Позволяет добавлять, изменять, удалять и извлекать данные (через язык SQL).
            *   **Определение данных:** Предоставляет средства для создания и изменения структуры базы (таблиц, индексов и т.д.) — через язык DDL.
            *   **Обеспечение целостности:** Следит за соблюдением правил и ограничений (например, уникальность первичных ключей), чтобы данные оставались непротиворечивыми.
            *   **Многопользовательский доступ:** Позволяет множеству пользователей одновременно работать с данными, управляя конкуренцией и блокировками.
            *   **Безопасность:** Управляет правами доступа пользователей к данным.
            *   **Восстановление:** Обеспечивает механизмы резервного копирования и восстановления данных после сбоев.

19. **Что произойдет, если попытаться добавить запись с уже существующим значением Primary Key?**
    *   **q:** Представь, что в таблице уже есть пользователь с `id = 5`. Ты пытаешься добавить еще одного пользователя, тоже с `id = 5`. Что случится?
    *   **a:**
        *   **Кратко:** СУБД вернет ошибку о нарушении уникальности (дубликате первичного ключа).
        *   **Подробно:** Так как первичный ключ по определению должен быть уникальным идентификатором, СУБД не позволит создать дубликат. Операция `INSERT` будет отклонена, и вы получите сообщение об ошибке, подобное "Duplicate entry '5' for key 'PRIMARY'". Это защищает целостность данных, не позволяя появиться двум разным записям с одним и тем же идентификатором.

20. **Может ли значение внешнего ключа быть пустым (NULL)?**
    *   **q:** Если у заказа может быть, а может и не быть привязанный пользователь (например, заказ для гостя), может ли поле `user_id` (внешний ключ) быть `NULL`?
    *   **a:**
        *   **Кратко:** Да, если связь необязательна.
        *   **Подробно:** Да, значение внешнего ключа может быть `NULL`, если бизнес-логика допускает отсутствие связи. Это означает, что данная запись в дочерней таблице не связана ни с одной записью в родительской таблице. В примере с гостевым заказом это вполне допустимо. Если же связь обязательна (например, каждый заказ должен принадлежать какому-то пользователю), то на столбец внешнего ключа накладывается ограничение `NOT NULL`.

### Сложный уровень

21. **Объясните разницу между понятиями «База данных» и «СУБД» на примере из реальной жизни.**
    *   **q:** Придумай метафору из жизни, которая наглядно покажет разницу между БД и СУБД.
    *   **a:**
        *   **Кратко:** БД — это библиотека (книги), а СУБД — библиотекарь.
        *   **Подробно:** Отличной метафорой будет библиотека. Сами книги, стоящие на полках в определенном порядке — это **база данных (БД)**. А **библиотекарь (СУБД)** — это система, которая управляет этой библиотекой: он знает, где какая книга лежит (каталог/индексы), может выдать вам книгу по запросу (`SELECT`), поставить новую книгу на полку (`INSERT`), заменить испорченную книгу (`UPDATE`) или убрать старую (`DELETE`). Библиотекарь также следит за порядком (целостность данных) и выдает книги только тем, у кого есть читательский билет (безопасность). Книги (данные) существуют сами по себе, но управлять ими без библиотекаря (СУБД) было бы крайне неэффективно.

22. **Что такое нормализация базы данных? Какие цели она преследует?**
    *   **q:** Объясни процесс нормализации данных. Зачем он нужен и какие проблемы решает?
    *   **a:**
        *   **Кратко:** Процесс организации данных для устранения избыточности и аномалий путем разделения на таблицы и определения связей.
        *   **Подробно:** Нормализация — это процесс проектирования реляционной базы данных, целью которого является устранение избыточности (дублирования) данных и обеспечение их целостности. Достигается это путем разбиения исходной информации на несколько связанных таблиц. Основные цели:
            *   **Устранение избыточности:** Чтобы одна и та же информация (например, адрес поставщика) не хранилась в сотнях строк с товарами. Это экономит место и упрощает обновление.
            *   **Предотвращение аномалий:** Аномалии — это проблемы, возникающие при добавлении, обновлении или удалении данных в неоптимально спроектированной таблице. Например, если мы удалим последнего поставщика товара, мы можем случайно удалить и информацию о самом товаре.
            *   **Обеспечение целостности:** Гарантия того, что данные остаются логически непротиворечивыми.
        Нормализация проходит через несколько форм (1НФ, 2НФ, 3НФ и т.д.), каждая из которых решает определенные проблемы.

23. **Что такое ACID?**
    *   **q:** Расшифруй аббревиатуру ACID и объясни, что означает каждый из принципов применительно к транзакциям в БД.
    *   **a:**
        *   **Кратко:** Набор свойств транзакций (Атомарность, Согласованность, Изоляция, Долговечность), гарантирующий надежность обработки данных.
        *   **Подробно:** ACID — это аббревиатура, описывающая требования к надежной транзакционной системе (например, к реляционной СУБД).
            *   **Атомарность (Atomicity):** Транзакция выполняется как единое целое ("все или ничего"). Если какая-то часть транзакции не может быть выполнена, отменяются все ее изменения. Пример: при переводе денег со счета на счет, обе операции (списание и зачисление) должны быть выполнены, иначе транзакция откатывается.
            *   **Согласованность (Consistency):** Транзакция переводит базу данных из одного целостного состояния в другое. Все правила, ограничения и триггеры должны быть соблюдены. Данные не должны быть "сломаны" после транзакции.
            *   **Изоляция (Isolation):** Параллельно выполняющиеся транзакции не должны влиять на результат друг друга. Создается иллюзия, что транзакции выполняются одна за другой, хотя реально они могут идти одновременно.
            *   **Долговечность (Durability):** После того как транзакция успешно завершена (закоммичена), ее изменения сохраняются даже в случае сбоя системы (например, отключения электричества). Данные записываются на диск.

24. **В чем разница между горизонтальным и вертикальным масштабированием БД?**
    *   **q:** Объясни два основных подхода к масштабированию базы данных, когда нагрузка на нее растет.
    *   **a:**
        *   **Кратко:** Вертикальное — увеличиваем мощность сервера. Горизонтальное — добавляем новые серверы.
        *   **Подробно:**
            *   **Вертикальное масштабирование (Scale Up):** Улучшение характеристик существующего сервера. Мы ставим более мощный процессор, добавляем оперативную память, заменяем HDD на SSD. Это проще с точки зрения управления (база остается на одной машине), но имеет физический предел (нельзя бесконечно улучшать один сервер) и может быть дорогостоящим.
            *   **Горизонтальное масштабирование (Scale Out):** Добавление новых серверов в кластер и распределение данных и нагрузки между ними. Это более сложный подход с архитектурной точки зрения (нужны механизмы синхронизации данных, балансировки), но он практически безграничен. Реляционные БД исторически сложнее масштабировать горизонтально, в то время как NoSQL-базы часто проектируются именно под этот вид масштабирования.

25. **Какие проблемы может вызвать отсутствие внешних ключей в реляционной БД?**
    *   **q:** Почему важно использовать внешние ключи? Что плохого может случиться с данными, если их не объявлять?
    *   **a:**
        *   **Кратко:** Нарушение целостности данных: появление "висячих" ссылок на несуществующие записи.
        *   **Подробно:** Если не использовать внешние ключи, связи между таблицами существуют только на уровне логики приложения, но не контролируются СУБД. Это может привести к нарушению ссылочной целостности. Например, в таблице "Заказы" есть `user_id = 15`. Если мы удалим пользователя с `id = 15` из таблицы "Пользователи", СУБД без внешнего ключа позволит это сделать. В результате в таблице заказов появятся "висячие" записи, которые ссылаются на несуществующего пользователя. Это приведет к ошибкам в приложении, которое попытается отобразить информацию о заказе. Внешний ключ предотвращает это: он либо запретит удаление пользователя, пока есть связанные заказы, либо автоматически удалит их (если настроено `ON DELETE CASCADE`).

26. **Для каких задач оптимально использовать графовые базы данных?**
    *   **q:** Приведи примеры, где использование графовой БД будет гораздо эффективнее, чем реляционной.
    *   **a:**
        *   **Кратко:** Для анализа связей: социальные сети, системы рекомендаций, выявление мошеннических схем.
        *   **Подробно:** Графовые базы данных специализируются на хранении и анализе связей. В них сущности — это узлы, а отношения между ними — ребра. Это делает их невероятно эффективными для задач, где важны именно связи:
            *   **Социальные сети:** Поиск друзей друзей, определение сообществ по интересам.
            *   **Системы рекомендаций:** "Люди, которые купили этот товар, также купили..." — это типичный графовый запрос.
            *   **Финансовый сектор/Антифрод:** Выявление мошеннических колец, когда группа людей с подозрительными транзакциями связана между собой.
            *   **Поиск оптимального маршрута:** В логистике или навигации.

27. **Что такое хранимая процедура?**
    *   **q:** Объясни, что такое хранимая процедура в SQL и зачем ее использовать.
    *   **a:**
        *   **Кратко:** Это набор SQL-инструкций, который хранится на сервере БД и может вызываться по имени.
        *   **Подробно:** Хранимая процедура — это объект базы данных, представляющий собой скомпилированный набор SQL-запросов и логики, который хранится на сервере. Представьте ее как функцию или метод в программировании, но на стороне базы данных. Ее преимущества:
            *   **Повторное использование:** Если часто нужна сложная выборка, можно написать процедуру один раз и вызывать ее многократно.
            *   **Производительность:** Процедуры хранятся в скомпилированном виде, что уменьшает время выполнения.
            *   **Безопасность:** Можно дать пользователю право вызывать процедуру, но не давать прямого доступа к таблицам.
            *   **Уменьшение сетевого трафика:** Вместо отправки на сервер пачки сложных запросов, клиент отправляет только имя процедуры и параметры.

28. **Какие существуют виды NoSQL баз данных и приведите примеры использования каждого?**
    *   **q:** Назови 4 основных типа NoSQL БД и приведи примеры реальных задач для каждого.
    *   **a:**
        *   **Кратко:** Key-Value (кэш), Документные (каталоги), Графовые (соцсети), Колоночные (аналитика).
        *   **Подробно:**
            *   **Ключ-значение (Key-Value):** Пример: **Redis**. Использование: Кэширование данных (сессии пользователей, временные данные), счетчики, очереди задач. Максимальная скорость доступа по ключу.
            *   **Документо-ориентированные (Document):** Пример: **MongoDB**. Использование: Каталоги товаров с разными характеристиками, системы управления контентом (блоги, статьи), логирование событий.
            *   **Графовые (Graph):** Пример: **Neo4j**. Использование: Социальные сети (друзья, подписчики), системы рекомендаций, анализ мошеннических транзакций, управление доступом (права, роли).
            *   **Колоночные (Wide-Column):** Пример: **Apache Cassandra**. Использование: Аналитика больших данных (Big Data), системы мониторинга, интернет вещей (IoT), где идет огромный поток данных с датчиков.

29. **Объясните, как вы понимаете «целостность данных» и какими способами она обеспечивается в реляционных БД.**
    *   **q:** Что значит "данные целостны"? Какие механизмы в реляционных БД помогают этого добиться?
    *   **a:**
        *   **Кратко:** Целостность данных — это соответствие данных реальной предметной области и их непротиворечивость. Обеспечивается ограничениями, типами данных и транзакциями.
        *   **Подробно:** Целостность означает, что данные точны, полны и непротиворечивы. Реляционные БД предоставляют несколько уровней защиты:
            *   **Целостность сущностей:** Гарантируется первичным ключом (Primary Key) — каждая строка уникальна.
            *   **Ссылочная целостность:** Гарантируется внешними ключами (Foreign Key) — связи между таблицами не нарушаются, нет "висячих" ссылок.
            *   **Доменная целостность:** Гарантируется типами данных (столбец `age` не может содержать буквы) и ограничениями `CHECK` (возраст не может быть отрицательным или больше 150).
            *   **Целостность, определяемая пользователем:** Специфические бизнес-правила, которые могут быть реализованы через триггеры или хранимые процедуры.
            *   **Транзакции (ACID):** Гарантируют, что группы операций будут выполнены полностью или не выполнены вовсе, сохраняя согласованность.

30. **Что такое «план запроса» и зачем его анализировать?**
    *   **q:** Представь, что SQL-запрос выполняется очень долго. Что такое "план запроса" и как он поможет найти проблему?
    *   **a:**
        *   **Кратко:** Это последовательность шагов, которую СУБД выполняет для получения данных по запросу. Его анализ нужен для оптимизации медленных запросов.
        *   **Подробно:** Когда вы отправляете SQL-запрос, СУБД не выполняет его буквально. Сначала оптимизатор строит план выполнения — это "дорожная карта" того, как именно будут извлекаться данные. В плане указано, будет ли использоваться индекс или будет полное сканирование таблицы, в каком порядке будут соединяться таблицы, какие методы сортировки применятся и так далее. Анализ плана запроса (используя команды `EXPLAIN` или `EXPLAIN ANALYZE`) — это ключевой навык для оптимизации производительности. Глядя на план, можно понять, почему запрос медленный (например, СУБД сканирует всю таблицу, хотя могла бы использовать индекс), и исправить это (например, создать нужный индекс или переписать запрос).

---

## Тема 2: SQL (Structured Query Language)

### Простой уровень

1.  **Что такое SQL?**
    *   **q:** Дай определение языку SQL и объясни, для чего он используется.
    *   **a:**
        *   **Кратко:** Structured Query Language — язык структурированных запросов для работы с данными в реляционных БД.
        *   **Подробно:** SQL (Структурированный язык запросов) — это специальный язык программирования, предназначенный для управления данными в реляционных системах управления базами данных (СУБД). Он позволяет выполнять различные операции: извлекать данные (`SELECT`), добавлять новые записи (`INSERT`), изменять существующие (`UPDATE`), удалять (`DELETE`), а также создавать и изменять структуру базы данных (таблицы, индексы). SQL является стандартом для работы с реляционными БД.

2.  **С помощью какой команды создается новая таблица?**
    *   **q:** Какое ключевое слово SQL используется для создания новой таблицы в базе данных?
    *   **a:**
        *   **Кратко:** `CREATE TABLE`
        *   **Подробно:** Команда `CREATE TABLE` относится к группе DDL (Data Definition Language). С ее помощью вы определяете структуру новой таблицы: задаете ее имя, перечисляете столбцы, указываете для каждого тип данных и возможные ограничения (например, PRIMARY KEY, NOT NULL). Пример: `CREATE TABLE students (id INT, name VARCHAR(50));`

3.  **Какая команда используется для получения данных из таблицы?**
    *   **q:** Какой SQL-оператор нужно написать, чтобы увидеть содержимое таблицы?
    *   **a:**
        *   **Кратко:** `SELECT`
        *   **Подробно:** Оператор `SELECT` — самый часто используемый оператор в SQL. Он предназначен для выборки данных из базы данных. С его помощью можно указать, какие именно столбцы вы хотите получить, из какой таблицы, применить фильтры, сортировку и многое другое. Простейший запрос выглядит так: `SELECT * FROM table_name;`, где `*` означает "все столбцы".

4.  **Как написать запрос, чтобы выбрать все столбцы из таблицы `users`?**
    *   **q:** Напиши SQL-запрос для просмотра всех данных, хранящихся в таблице с именем `users`.
    *   **a:**
        *   **Кратко:** `SELECT * FROM users;`
        *   **Подробно:** Запрос `SELECT * FROM users;` означает: "Выбрать все (`*`) столбцы из таблицы `users`". Символ `*` (звездочка) используется как сокращение для указания всех столбцов таблицы. `FROM` указывает, из какой именно таблицы мы выбираем данные. Это самый простой способ быстро посмотреть содержимое таблицы.

5.  **С помощью какой команды добавляются новые записи в таблицу?**
    *   **q:** Как добавить новую строку с данными в существующую таблицу?
    *   **a:**
        *   **Кратко:** `INSERT`
        *   **Подробно:** Оператор `INSERT` используется для добавления новых строк (записей) в таблицу. Существует два основных синтаксиса: `INSERT INTO table_name VALUES (value1, value2, ...);` (требует значений для всех столбцов в порядке их определения) и более предпочтительный: `INSERT INTO table_name (column1, column2) VALUES (value1, value2);`, где явно указывается, в какие столбцы вставляются значения.

6.  **Какая команда изменяет существующие данные в таблице?**
    *   **q:** Нужно исправить опечатку в имени пользователя в базе данных. Какой оператор для этого используется?
    *   **a:**
        *   **Кратко:** `UPDATE`
        *   **Подробно:** Оператор `UPDATE` используется для изменения данных в уже существующих строках таблицы. Важно помнить, что `UPDATE` почти всегда используется вместе с условием `WHERE`, чтобы указать, какие именно строки нужно обновить. Без `WHERE` будут обновлены все строки таблицы. Синтаксис: `UPDATE table_name SET column1 = new_value1 WHERE condition;`

7.  **Какая команда удаляет данные из таблицы?**
    *   **q:** Как удалить конкретную запись (строку) из таблицы?
    *   **a:**
        *   **Кратко:** `DELETE`
        *   **Подробно:** Оператор `DELETE` используется для удаления строк из таблицы. Как и в случае с `UPDATE`, критически важно использовать условие `WHERE`, чтобы удалить только нужные строки. Запрос `DELETE FROM table_name;` без `WHERE` удалит все строки в таблице. Синтаксис: `DELETE FROM table_name WHERE condition;`

8.  **Какой оператор используется для фильтрации строк в запросе `SELECT`?**
    *   **q:** Как вывести только тех пользователей, которым больше 18 лет? Какой оператор SQL поможет задать это условие?
    *   **a:**
        *   **Кратко:** `WHERE`
        *   **Подробно:** Оператор `WHERE` используется для фильтрации записей. Он применяется в запросах `SELECT`, `UPDATE`, `DELETE` для указания условия, которому должны соответствовать строки, с которыми будет произведено действие. В примере с пользователями старше 18 лет запрос будет выглядеть так: `SELECT * FROM users WHERE age > 18;`

9.  **Как отсортировать результат запроса?**
    *   **q:** Как вывести список студентов в алфавитном порядке их имен?
    *   **a:**
        *   **Кратко:** `ORDER BY`
        *   **Подробно:** Для сортировки результатов запроса используется оператор `ORDER BY`. По умолчанию сортировка происходит по возрастанию (`ASC`). Для сортировки по убыванию используется ключевое слово `DESC`. Пример: `SELECT * FROM students ORDER BY name ASC;` (или просто `ORDER BY name`).

10. **Что делает оператор `LIKE`?**
    *   **q:** Как найти всех пользователей, чей email зарегистрирован на домене "gmail.com"? Какой оператор поможет в поиске по шаблону?
    *   **a:**
        *   **Кратко:** Используется для поиска по шаблону в текстовых полях.
        *   **Подробно:** Оператор `LIKE` применяется в условии `WHERE` для поиска по заданному шаблону. Он использует два символа-шаблона: `%` (любое количество любых символов, включая ноль) и `_` (один любой символ). Для поиска всех email на gmail.com запрос будет: `SELECT * FROM users WHERE email LIKE '%@gmail.com';`

### Средний уровень

11. **Чем отличается `DELETE` от `TRUNCATE`?**
    *   **q:** В чем разница между командами `DELETE FROM table;` и `TRUNCATE TABLE table;`? Какая из них быстрее и почему?
    *   **a:**
        *   **Кратко:** `DELETE` удаляет строки по условию (можно откатить), `TRUNCATE` быстро удаляет все строки и сбрасывает счетчики (нельзя откатить в большинстве СУБД).
        *   **Подробно:**
            *   **DELETE:** Это DML-операция. Она удаляет строки по одной, и для каждой строки записывается информация в лог транзакций. Это позволяет использовать `ROLLBACK` для отмены удаления. Можно использовать с условием `WHERE`. Не сбрасывает счетчики автоинкремента. Работает медленнее при большом объеме данных.
            *   **TRUNCATE:** Это DDL-операция. Она просто освобождает блоки данных, выделенные под таблицу. Это очень быстрая операция, но она не может быть отменена в большинстве СУБД. `TRUNCATE` нельзя применить с `WHERE` — он всегда удаляет все строки. Счетчики автоинкремента обычно сбрасываются.

12. **В чем разница между `WHERE` и `HAVING`?**
    *   **q:** В SQL есть два похожих оператора для фильтрации: `WHERE` и `HAVING`. В чем ключевое различие в их применении?
    *   **a:**
        *   **Кратко:** `WHERE` фильтрует строки ДО группировки, а `HAVING` фильтрует группы ПОСЛЕ группировки (`GROUP BY`).
        *   **Подробно:**
            *   **WHERE** применяется к отдельным строкам таблицы на этапе их выборки. Нельзя использовать агрегатные функции (SUM, COUNT и т.д.) в условии `WHERE`.
            *   **HAVING** применяется после того, как строки были сгруппированы с помощью `GROUP BY`. Оно используется для фильтрации уже созданных групп, и в его условии можно (и обычно нужно) использовать агрегатные функции. Пример: `SELECT course_id, COUNT(*) FROM enrollments GROUP BY course_id HAVING COUNT(*) > 5;` (найти курсы, на которые записано более 5 студентов).

13. **Для чего используется оператор `JOIN`?**
    *   **q:** Если данные о пользователях хранятся в одной таблице, а данные об их заказах — в другой, как получить единую таблицу с именем пользователя и его заказом?
    *   **a:**
        *   **Кратко:** Для объединения данных из двух или более таблиц по связанному столбцу.
        *   **Подробно:** Оператор `JOIN` (и его разновидности) используется для соединения строк из двух или более таблиц на основе связанного между ними столбца (обычно это внешний и первичный ключи). Это позволяет получить в результате запроса поля из всех соединяемых таблиц, как если бы они были одной большой таблицей.

14. **Что такое первичный ключ в контексте SQL? Как он задается?**
    *   **q:** Как на языке SQL объявить, что столбец `id` в таблице будет первичным ключом?
    *   **a:**
        *   **Кратко:** Это ограничение, которое уникально идентифицирует каждую запись. Задается с помощью `PRIMARY KEY` при создании (`CREATE TABLE`) или изменении (`ALTER TABLE`) таблицы.
        *   **Подробно:** В SQL первичный ключ — это ограничение (constraint), которое гарантирует уникальность и непустоту значений в указанном столбце (или группе столбцов). Существует два способа его задать:
            *   **Внутри определения столбца:** `id INT PRIMARY KEY`
            *   **После определения всех столбцов:** `PRIMARY KEY (id)`
        Второй способ обязателен, если ключ состоит из нескольких столбцов (составной ключ).

15. **Какой тип `JOIN` нужно использовать, чтобы выбрать все строки из левой таблицы и только совпадающие из правой?**
    *   **q:** Нужно вывести список всех курсов и имена студентов, которые на них записаны. Если на курс никто не записан, название курса все равно должно быть показано. Какой JOIN для этого подойдет?
    *   **a:**
        *   **Кратко:** `LEFT JOIN`
        *   **Подробно:** `LEFT JOIN` (или `LEFT OUTER JOIN`) возвращает ВСЕ строки из левой таблицы (той, что указана после `FROM`). Если в правой таблице (после `JOIN`) есть соответствующие строки (по условию `ON`), они добавляются. Если соответствующих строк нет, то для столбцов правой таблицы в результате будут значения `NULL`. Для нашего примера левой таблицей должны быть курсы: `SELECT * FROM courses LEFT JOIN enrollments ...`

16. **Что означает символ `%` в операторе `LIKE`?**
    *   **q:** В запросе `WHERE name LIKE 'A%'` что означает символ процента? Что найдет этот запрос?
    *   **a:**
        *   **Кратко:** Любое количество любых символов, включая ноль.
        *   **Подробно:** В операторе `LIKE` символ `%` (процент) является подстановочным знаком (wildcard). Он означает последовательность из нуля, одного или нескольких любых символов. Запрос `WHERE name LIKE 'A%'` найдет все имена, начинающиеся с буквы 'A' (например, 'Alex', 'Anna', 'A'). А запрос `'%a'` найдет все имена, заканчивающиеся на 'a'.

17. **Для чего используется `DISTINCT`?**
    *   **q:** В таблице `enrollments` много записей, и нужно узнать, какие уникальные `student_id` там встречаются. Какой оператор поможет убрать дубликаты из результата?
    *   **a:**
        *   **Кратко:** Для удаления дубликатов из результата выборки.
        *   **Подробно:** Ключевое слово `DISTINCT` используется в запросе `SELECT` для того, чтобы в результате остались только уникальные комбинации значений указанных столбцов. Например, `SELECT DISTINCT student_id FROM enrollments;` вернет список ID студентов, которые записаны хотя бы на один курс, без повторений, даже если один студент записан на несколько курсов.

18. **Что такое агрегатные функции в SQL? Назовите основные.**
    *   **q:** Какие функции в SQL позволяют посчитать количество записей, найти среднее значение или сумму по столбцу?
    *   **a:**
        *   **Кратко:** Функции, выполняющие вычисления на наборе строк и возвращающие одно значение. Основные: `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`.
        *   **Подробно:** Агрегатные функции принимают набор значений (например, весь столбец или результат после фильтрации) и возвращают одно итоговое значение. Они часто используются вместе с `GROUP BY`.
            *   `COUNT(*)` или `COUNT(column)` — подсчитывает количество строк или не-NULL значений в столбце.
            *   `SUM(column)` — вычисляет сумму всех значений в числовом столбце.
            *   `AVG(column)` — вычисляет среднее арифметическое значений в числовом столбце.
            *   `MIN(column)` — находит минимальное значение в столбце.
            *   `MAX(column)` — находит максимальное значение в столбце.

19. **Как ограничить количество возвращаемых записей?**
    *   **q:** В таблице миллион записей, но для теста нужно посмотреть всего 10 первых. Какое ключевое слово SQL поможет это сделать?
    *   **a:**
        *   **Кратко:** `LIMIT`
        *   **Подробно:** Оператор `LIMIT` используется для ограничения количества строк, возвращаемых запросом `SELECT`. Это очень полезно для тестирования запросов на больших таблицах, а также для реализации постраничной навигации (pagination). Пример: `SELECT * FROM users LIMIT 10;` вернет только первые 10 строк. В некоторых СУБД (например, MS SQL Server) используется `TOP`, а в Oracle — `ROWNUM` или `FETCH FIRST`.

20. **Какой синтаксис используется для обновления данных?**
    *   **q:** Напиши общий шаблон SQL-запроса для изменения значения столбца `status` на 'active' для пользователя с `id = 1`.
    *   **a:**
        *   **Кратко:** `UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;`
        *   **Подробно:** Команда `UPDATE` всегда требует:
            1.  Имя таблицы (`UPDATE table_name`).
            2.  Одну или несколько пар столбец=значение после ключевого слова `SET`.
            3.  Условие `WHERE`, которое определяет, какие именно строки будут изменены. Без `WHERE` обновятся ВСЕ строки.
        Конкретно для примера: `UPDATE users SET status = 'active' WHERE id = 1;`

### Сложный уровень

21. **Объясните разницу между `INNER JOIN` и `LEFT JOIN`. Приведите пример, когда результаты запросов будут одинаковы.**
    *   **q:** Когда `INNER JOIN` и `LEFT JOIN` могут вернуть абсолютно одинаковый результат? При каких условиях это произойдет?
    *   **a:**
        *   **Кратко:** Результаты будут одинаковы, если в правой таблице для каждой строки левой есть соответствующая запись, и нет дополнительных фильтров.
        *   **Подробно:**
            *   `INNER JOIN` возвращает только те строки, для которых нашлось соответствие в обеих таблицах.
            *   `LEFT JOIN` возвращает все строки из левой таблицы, а данные из правой подтягиваются только там, где есть соответствие. Где соответствия нет, поля правой таблицы будут `NULL`.
        Результаты двух запросов будут идентичны в том случае, если в правой таблице есть соответствующая запись для КАЖДОЙ строки левой таблицы. Например, если у нас есть таблица студентов и таблица их паспортных данных, и мы знаем, что у каждого студента есть паспортные данные, то запросы с `INNER JOIN` и `LEFT JOIN` (где левая таблица — студенты) вернут одно и то же множество строк (хотя `LEFT JOIN` может быть чуть медленнее, так как делает лишнюю работу, пытаясь найти NULL-значения).

22. **Что такое подзапрос (subquery)? Где его можно использовать?**
    *   **q:** Как с помощью одного SQL-запроса найти студентов, которые записаны на тот же курс, что и студент с именем 'Иван'? (Не зная ID Ивана заранее)
    *   **a:**
        *   **Кратко:** Запрос внутри другого запроса. Может использоваться в `SELECT`, `FROM`, `WHERE`, `HAVING`.
        *   **Подробно:** Подзапрос — это полноценный SQL-запрос, вложенный внутрь другого запроса (внешнего запроса). Результат подзапроса используется внешним запросом. Подзапросы могут находиться в разных частях:
            *   **В `WHERE`:** Обычно с операторами `IN`, `EXISTS`, сравнениями. Пример для задачи: `SELECT student_id FROM enrollments WHERE course_id IN (SELECT course_id FROM enrollments JOIN students ON enrollments.student_id = students.id WHERE students.name = 'Иван');` (и потом еще один уровень для получения имен).
            *   **В `FROM`:** Подзапрос выступает в роли временной таблицы.
            *   **В `SELECT`:** Подзапрос используется для вычисления скалярного значения для каждой строки.

23. **Что такое транзакция? Какими командами она управляется?**
    *   **q:** Представь операцию перевода денег с карты на карту. Почему важно, чтобы она выполнялась как одно целое, и как в SQL это реализовать?
    *   **a:**
        *   **Кратко:** Транзакция — это последовательность операций, которая выполняется как единое целое. Команды: `BEGIN` (`START TRANSACTION`), `COMMIT`, `ROLLBACK`.
        *   **Подробно:** Транзакция группирует несколько SQL-операций в один атомарный блок. Это означает, что либо будут выполнены все операции в блоке, либо не будет выполнена ни одна.
            *   `BEGIN` или `START TRANSACTION` — начинает новую транзакцию.
            *   `COMMIT` — фиксирует (сохраняет) все изменения, сделанные в текущей транзакции, делая их постоянными.
            *   `ROLLBACK` — откатывает (отменяет) все изменения, сделанные в текущей транзакции с момента ее начала.
        В примере с переводом денег, транзакция будет состоять из двух операций: списание со счета А и зачисление на счет Б. Если после списания произойдет ошибка, `ROLLBACK` отменит списание, и деньги не пропадут.

24. **Для чего используется `GROUP BY`? Приведите пример с агрегатной функцией.**
    *   **q:** Как посчитать количество студентов на каждом курсе? Как сгруппировать данные и применить к ним функцию подсчета?
    *   **a:**
        *   **Кратко:** `GROUP BY` группирует строки с одинаковыми значениями в указанных столбцах, чтобы затем применить агрегатные функции к каждой группе.
        *   **Подробно:** `GROUP BY` позволяет разбить строки таблицы на группы по значениям одного или нескольких столбцов. Затем к каждой такой группе можно применить агрегатную функцию, получив одно итоговое значение для группы. В примере с подсчетом студентов на курсах, мы группируем записи из таблицы `enrollments` по `course_id` и считаем количество записей в каждой группе: `SELECT course_id, COUNT(student_id) AS students_count FROM enrollments GROUP BY course_id;`. Чтобы увидеть названия курсов, нужно сделать `JOIN` с таблицей `courses`.

25. **Чем `UNION` отличается от `JOIN`?**
    *   **q:** Какая фундаментальная разница в том, как `UNION` и `JOIN` соединяют данные?
    *   **a:**
        *   **Кратко:** `JOIN` объединяет столбцы разных таблиц горизонтально. `UNION` объединяет результаты двух запросов вертикально.
        *   **Подробно:**
            *   **`JOIN`** (соединение) расширяет результат по горизонтали, добавляя к строкам из левой таблицы столбцы из правой таблицы на основе условия.
            *   **`UNION`** (объединение) расширяет результат по вертикали, добавляя строки из второго запроса под строки из первого. Для использования `UNION` оба запроса должны возвращать одинаковое количество столбцов и совместимые типы данных в соответствующих столбцах. `UNION` автоматически удаляет дубликаты, а `UNION ALL` — нет (работает быстрее).

26. **В чем разница между `VARCHAR(255)` и `TEXT`?**
    *   **q:** Для хранения короткого имени пользователя и длинной статьи в блоге вы выберете разные типы данных. Почему? В чем разница между `VARCHAR` и `TEXT`?
    *   **a:**
        *   **Кратко:** `VARCHAR` — для строк ограниченной длины, может полностью индексироваться. `TEXT` — для длинных текстов, часто имеет ограничения на индексацию и хранение.
        *   **Подробно:**
            *   **`VARCHAR(n)`** (Variable Character) — используется для хранения строк переменной длины, но с максимальным лимитом `n`. Данные обычно хранятся прямо в строке таблицы, что делает их более быстрыми для чтения и позволяет создавать полноценные индексы по этому столбцу. Идеально для полей, где длина известна и ограничена (имя, email, адрес).
            *   **`TEXT`** — предназначен для хранения больших объемов текстовых данных (статьи, описания, комментарии). Часто данные типа `TEXT` хранятся отдельно от основной строки таблицы, что делает доступ к ним чуть медленнее. Индексация `TEXT` полей либо ограничена (нельзя создать обычный индекс), либо требует указания префикса. Это сделано для экономии производительности.

27. **Что такое «инъекция SQL» (SQL injection)? Как тестировщик может ее обнаружить?**
    *   **q:** Представь, что в поле ввода логина на сайте ты вводишь не просто имя, а SQL-код. Что это за атака и как ее можно попробовать обнаружить при тестировании?
    *   **a:**
        *   **Кратко:** Это уязвимость, позволяющая внедрить вредоносный SQL-код в запрос. Обнаружить можно, вводя спецсимволы (', ", --) и наблюдая за ошибками или поведением.
        *   **Подробно:** SQL-инъекция — это один из самых опасных видов атак на веб-приложения. Она возникает, когда приложение вставляет пользовательский ввод (например, из формы логина) в SQL-запрос без должной обработки или экранирования. Злоумышленник может "закрыть" кавычкой предполагаемое значение и дописать свой SQL-код, чтобы изменить логику запроса (например, `' OR '1'='1` для обхода авторизации) или даже выполнить деструктивные команды (`'; DROP TABLE users; --`). Тестировщик может попытаться обнаружить инъекцию, вводя в поля ввода одиночные кавычки (`'`), двойные кавычки (`"`), SQL-команды и наблюдая за тем, не приводит ли это к ошибкам базы данных (они могут отобразиться на экране) или к нештатному поведению приложения.

28. **Что произойдет при выполнении запроса `DELETE FROM users;` без условия `WHERE`?**
    *   **q:** Какой будет результат выполнения такого запроса? Это опасно?
    *   **a:**
        *   **Кратко:** Будут удалены все строки из таблицы `users`.
        *   **Подробно:** Это крайне опасная операция. Поскольку условие `WHERE` не указано, команда `DELETE` применится ко всем строкам таблицы, и все данные из таблицы `users` будут безвозвратно удалены (если только операция не выполняется внутри транзакции, которую можно откатить). Именно поэтому в рабочих базах данных права на выполнение `DELETE` без `WHERE` часто строго ограничиваются, а выполнение таких запросов требует особой осторожности и проверки.

29. **Объясните порядок выполнения SQL-запроса (логический порядок операций).**
    *   **q:** Напиши запрос `SELECT` с `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY` и `LIMIT`. В каком порядке на самом деле обрабатываются эти ключевые слова? (Не в том, в каком они пишутся в коде).
    *   **a:**
        *   **Кратко:** FROM -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT.
        *   **Подробно:** Несмотря на то, что в запросе `SELECT` мы пишем `SELECT` первым, логически он выполняется в другом порядке:
            1.  **FROM и JOIN:** Сначала определяются источники данных и выполняются все соединения таблиц. Создается виртуальная рабочая таблица.
            2.  **WHERE:** Затем фильтруются отдельные строки этой таблицы.
            3.  **GROUP BY:** Оставшиеся строки группируются.
            4.  **HAVING:** Фильтруются уже созданные группы.
            5.  **SELECT:** Теперь вычисляются и выбираются конкретные столбцы, выражения, агрегатные функции для итогового набора строк (или групп).
            6.  **ORDER BY:** Результат сортируется.
            7.  **LIMIT / OFFSET:** И только в самом конце ограничивается количество выводимых строк.

30. **Что такое оконные функции (window functions)? Приведите пример.**
    *   **q:** Чем оконные функции отличаются от обычных агрегатных (`GROUP BY`)? Как, например, вывести список студентов и для каждого показать, каким по счету он записался на свой курс?
    *   **a:**
        *   **Кратко:** Функции, которые выполняют вычисления для набора строк, связанных с текущей строкой, но при этом не группируют их в одну строку вывода.
        *   **Подробно:** Агрегатные функции с `GROUP BY` сжимают множество строк в одну строку результата. Оконные функции выполняют вычисления над "окном" — набором строк, связанных с текущей, но при этом каждая исходная строка остается отдельной строкой в результате. У них есть синтаксис `OVER(...)`. Пример для задачи: `SELECT name, course_id, ROW_NUMBER() OVER (PARTITION BY course_id ORDER BY enrollment_date) AS enrollment_order FROM students JOIN enrollments ON ...;`. Здесь `ROW_NUMBER()` пронумерует студентов в рамках каждого курса (`PARTITION BY course_id`) по дате записи, не теряя при этом информации о каждом студенте отдельно.

---

## Тема 3: Практика SQL (на основе предоставленных скриптов)

### Простой уровень

1.  **Напишите запрос, который покажет все содержимое таблицы `students`.**
    *   **q:** Тебе нужно быстро увидеть всех студентов, которые есть в базе, со всеми их данными. Какой запрос ты напишешь?
    *   **a:**
        *   **Кратко:** `SELECT * FROM students;`
        *   **Подробно:** Это базовый запрос на выборку всех данных. Оператор `*` (звездочка) означает "все столбцы". Таким образом, мы получим все строки и все колонки, которые есть в таблице `students`. Это полезно для первичного ознакомления с данными.

2.  **Напишите запрос, который добавит нового студента с именем 'Елена' в таблицу `students`.**
    *   **q:** В отдел пришла новая студентка Елена. Добавь ее в общий список (таблицу `students`).
    *   **a:**
        *   **Кратко:** `INSERT INTO students (id, name) VALUES (4, 'Елена');` (или без `id`, если он автоинкрементный).
        *   **Подробно:** Для добавления новых записей используется команда `INSERT`. Важно указать таблицу и перечислить значения для вставки. Если столбец `id` имеет свойство `AUTO_INCREMENT`, то его можно не указывать, и база данных присвоит следующий уникальный номер автоматически. В таком случае запрос будет: `INSERT INTO students (name) VALUES ('Елена');`. Если автоинкремента нет, нужно явно указать новый уникальный `id`.

3.  **Как вывести только имена всех студентов из таблицы `students`?**
    *   **q:** Тебя интересует только список имен студентов, без их идентификаторов. Какой запрос это сделает?
    *   **a:**
        *   **Кратко:** `SELECT name FROM students;`
        *   **Подробно:** Вместо символа `*`, который выбирает все столбцы, мы явно указываем имя нужного нам столбца — `name`. В результате запрос вернет одну колонку, содержащую все имена из таблицы.

4.  **Напишите запрос для поиска студента по имени 'Иван'.**
    *   **q:** Найди в таблице `students` запись, которая относится к студенту по имени Иван. Нужно увидеть всю информацию о нем.
    *   **a:**
        *   **Кратко:** `SELECT * FROM students WHERE name = 'Иван';`
        *   **Подробно:** Для фильтрации данных мы используем оператор `WHERE`. В условии мы указываем, что нас интересуют только те строки, где значение в столбце `name` точно равно строке 'Иван'. Важно помнить, что строковые значения в SQL заключаются в одинарные кавычки.

5.  **Какой запрос выведет все курсы, отсортированные по названию по убыванию?**
    *   **q:** Выведи список всех курсов в обратном алфавитном порядке названий.
    *   **a:**
        *   **Кратко:** `SELECT * FROM courses ORDER BY course_name DESC;`
        *   **Подробно:** За сортировку отвечает оператор `ORDER BY`. Мы указываем столбец, по которому хотим отсортировать (`course_name`). По умолчанию сортировка идет по возрастанию (`ASC`). Чтобы изменить порядок на обратный, мы добавляем ключевое слово `DESC` (descending).

6.  **Напишите запрос, который обновит название курса с `id=3` на 'Автоматизация тестирования'.**
    *   **q:** Курс "Тестирование ПО" переименовали в "Автоматизация тестирования". Обнови эту информацию в таблице `courses`.
    *   **a:**
        *   **Кратко:** `UPDATE courses SET course_name = 'Автоматизация тестирования' WHERE id = 3;`
        *   **Подробно:** Это запрос на обновление данных. Критически важной частью здесь является условие `WHERE id = 3`. Оно гарантирует, что мы изменим название только у одной конкретной строки — курса с идентификатором 3. Если бы мы опустили `WHERE`, то переименовали бы *все* курсы в 'Автоматизация тестирования'.

7.  **Как удалить студента с `id=2` из таблицы `students`?**
    *   **q:** Студент с идентификатором 2 отчислился. Удали его запись из таблицы.
    *   **a:**
        *   **Кратко:** `DELETE FROM students WHERE id = 2;`
        *   **Подробно:** Оператор `DELETE` удаляет строки. Как и в случае с `UPDATE`, наличие условия `WHERE` здесь обязательно, если мы не хотим удалить всех студентов. Мы точно указываем, что хотим удалить только ту строку, где значение столбца `id` равно 2.

8.  **Напишите запрос, который выберет всех пользователей из таблицы `users`, которым больше 30 лет.**
    *   **q:** В таблице `users` есть столбец `age`. Выбери всех совершеннолетних пользователей старше 30 лет.
    *   **a:**
        *   **Кратко:** `SELECT * FROM users WHERE age > 30;`
        *   **Подробно:** Простая фильтрация по числовому значению. Оператор `WHERE` отбирает строки, где значение в столбце `age` строго больше 30. Можно использовать и другие операторы сравнения: `<`, `>=`, `<=`, `=`.

9.  **Как вставить новую запись о профессии в таблицу `profession` для пользователя с `user_id=1`?**
    *   **q:** У пользователя с `id=1` появилась новая профессия. Добавь запись в таблицу `profession`, указав название профессии, например, 'Data Analyst'.
    *   **a:**
        *   **Кратко:** `INSERT INTO profession (name_prof, user_id) VALUES ('Data Analyst', 1);`
        *   **Подробно:** Таблица `profession` связывает профессию и пользователя через поле `user_id`. В этом запросе мы явно указываем, что вставляем значение 'Data Analyst' в столбец `name_prof` и значение `1` в столбец `user_id`. Столбец `id` мы опустили, предполагая, что он заполняется автоматически (`AUTOINCREMENT`).

10. **Напишите запрос, который выберет все курсы, в названии которых есть слово "SQL".**
    *   **q:** В таблице `courses` нужно найти все курсы, связанные с SQL, то есть те, в названии которых встречается подстрока "SQL".
    *   **a:**
        *   **Кратко:** `SELECT * FROM courses WHERE course_name LIKE '%SQL%';`
        *   **Подробно:** Для поиска по части строки используется оператор `LIKE` и символы-шаблоны. Шаблон `'%SQL%'` означает: любое количество любых символов в начале (`%`), затем точно буквы 'SQL', затем снова любое количество любых символов. Такой запрос найдет и "SQL для начинающих", и "Продвинутый SQL", и "PL/SQL".

### Средний уровень

11. **Напишите запрос с `JOIN`, чтобы вывести имена студентов и названия курсов, на которые они записаны.**
    *   **q:** Необходимо получить отчет, в котором будет видно, кто из студентов (`students`) на какие курсы (`courses`) записан. Данные о связях хранятся в таблице `enrollments`.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT students.name, courses.course_name
            FROM enrollments
            JOIN students ON enrollments.student_id = students.id
            JOIN courses ON enrollments.course_id = courses.id;
            ```
        *   **Подробно:** Это классический пример соединения трех таблиц. Мы начинаем с таблицы связей `enrollments`, так как она содержит ссылки на обе нужные таблицы. Затем мы присоединяем к ней таблицу `students` по условию `enrollments.student_id = students.id`, чтобы получить имя студента для каждой записи о зачислении. Аналогично присоединяем таблицу `courses` по условию `enrollments.course_id = courses.id`, чтобы получить название курса. В результате каждая строка будет содержать имя студента и название курса, на который он записан.

12. **Найдите имена студентов, которые записаны на курс "Тестирование ПО".**
    *   **q:** Нужно составить список студентов, которые выбрали курс "Тестирование ПО". (Используй таблицы из предыдущих заданий).
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT students.name
            FROM students
            JOIN enrollments ON students.id = enrollments.student_id
            JOIN courses ON enrollments.course_id = courses.id
            WHERE courses.course_name = 'Тестирование ПО';
            ```
        *   **Подробно:** Задача похожа на предыдущую, но с дополнительным условием. Сначала мы соединяем таблицы, чтобы связать студентов с курсами. Затем с помощью оператора `WHERE` мы фильтруем результат, оставляя только те строки, где название курса равно 'Тестирование ПО'. В итоге мы получаем имена только тех студентов, которые соответствуют этому условию.

13. **Как с помощью `LEFT JOIN` вывести все курсы и имена студентов, которые на них записаны (включая курсы, на которые никто не записан)?**
    *   **q:** Есть список всех курсов. Нужно увидеть, какие курсы пользуются популярностью, а какие — нет. То есть показать все курсы, и если на курс кто-то записан, показать этих студентов.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT courses.course_name, students.name
            FROM courses
            LEFT JOIN enrollments ON courses.id = enrollments.course_id
            LEFT JOIN students ON enrollments.student_id = students.id;
            ```
        *   **Подробно:** Здесь левой таблицей мы делаем `courses`, так как хотим видеть все курсы. Первый `LEFT JOIN` со связующей таблицей `enrollments` гарантирует, что все курсы останутся в результате. Если на курс есть записи, они подтянутся. Если нет, то столбцы из `enrollments` будут `NULL`. Второй `LEFT JOIN` нужен, чтобы по имеющимся (или отсутствующим) `student_id` подтянуть имена студентов. В итоге для курсов без студентов в колонке `students.name` будет `NULL`.

14. **Посчитайте, сколько студентов записано на каждый курс.**
    *   **q:** Составь рейтинг популярности курсов: для каждого курса нужно вывести его название и количество записанных на него студентов.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT courses.course_name, COUNT(enrollments.student_id) AS students_count
            FROM courses
            LEFT JOIN enrollments ON courses.id = enrollments.course_id
            GROUP BY courses.id, courses.course_name;
            ```
        *   **Подробно:** Сначала мы соединяем курсы с таблицей зачислений (через `LEFT JOIN`, чтобы учесть курсы с нулем студентов). Затем с помощью `GROUP BY` мы группируем результат по каждому курсу. И, наконец, для каждой группы (для каждого курса) с помощью агрегатной функции `COUNT` подсчитываем количество не-NULL значений `enrollments.student_id` — это и будет число студентов на курсе.

15. **Напишите запрос, который выберет имена всех пользователей из таблицы `users`, у которых имя заканчивается на букву "а".**
    *   **q:** В таблице `users` найди всех женщин? (По условию, что их имена заканчиваются на букву "а").
    *   **a:**
        *   **Кратко:** `SELECT * FROM users WHERE name LIKE '%a';`
        *   **Подробно:** Используем оператор `LIKE` с шаблоном. Символ `%` означает любую последовательность символов в начале. Условие `LIKE '%a'` означает: любое имя, которое заканчивается на букву "а".

16. **Добавьте 5 новых студентов в таблицу `students` одним запросом.**
    *   **q:** В таблицу `students` нужно быстро добавить сразу несколько новых записей. Как это сделать эффективно, не вставляя каждую строку отдельным запросом?
    *   **a:**
        *   **Кратко:**
            ```sql
            INSERT INTO students (id, name) VALUES
            (5, 'Анна'),
            (6, 'Петр'),
            (7, 'Света'),
            (8, 'Дмитрий'),
            (9, 'Ольга');
            ```
        *   **Подробно:** SQL позволяет вставлять несколько строк одной командой `INSERT`. Для этого после `VALUES` перечисляются наборы значений в круглых скобках, разделенные запятыми. Это значительно быстрее и эффективнее, чем выполнять пять отдельных запросов. Если `id` автоинкрементный, столбец `id` и его значения можно опустить.

17. **Выберите всех студентов из таблицы `students`, у которых длина имени больше 4 символов.**
    *   **q:** В таблице `students` нужно отфильтровать студентов по длине имени, оставив только тех, у кого имя длиннее 4 букв.
    *   **a:**
        *   **Кратко:** `SELECT * FROM students WHERE LENGTH(name) > 4;`
        *   **Подробно:** В условии `WHERE` можно использовать не только значения столбцов, но и функции, применяемые к этим столбцам. Функция `LENGTH()` (или `LEN()` в некоторых СУБД) возвращает длину строки. Мы применяем её к столбцу `name` и сравниваем результат с числом 4.

18. **Напишите запрос, который покажет имена студентов и названия курсов, используя псевдонимы (alias) для таблиц.**
    *   **q:** Перепиши запрос из задания №11, используя короткие имена (псевдонимы) для таблиц `students`, `courses` и `enrollments`, чтобы сделать запрос более кратким.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT s.name, c.course_name
            FROM enrollments e
            JOIN students s ON e.student_id = s.id
            JOIN courses c ON e.course_id = c.id;
            ```
        *   **Подробно:** Псевдонимы таблиц задаются сразу после имени таблицы (например, `students s`). После этого везде в запросе можно обращаться к таблице по этому короткому имени. Это особенно удобно в сложных запросах с множеством соединений, так как делает код чище и уменьшает вероятность опечаток.

19. **Обновите таблицу `users`, установив возраст (age) равным 30 для пользователя с именем 'Den'.**
    *   **q:** У пользователя Den сегодня день рождения, и ему исполнилось 30 лет. Обнови его возраст в таблице `users`.
    *   **a:**
        *   **Кратко:** `UPDATE users SET age = 30 WHERE name = 'Den';`
        *   **Подробно:** Простой запрос на обновление. Важно, что мы используем условие `WHERE name = 'Den'`. Однако этот запрос обновит всех пользователей с именем Den, если их несколько. Если имена могут повторяться, надежнее использовать условие по уникальному идентификатору `id`.

20. **Выведите уникальные названия профессий из таблицы `profession`.**
    *   **q:** Посмотри, какие вообще профессии встречаются в таблице `profession`, без повторений.
    *   **a:**
        *   **Кратко:** `SELECT DISTINCT name_prof FROM profession;`
        *   **Подробно:** Ключевое слово `DISTINCT` после `SELECT` гарантирует, что в результате не будет дублирующихся строк. Мы получим простой список уникальных названий профессий, которые есть в таблице.

### Сложный уровень

21. **Напишите запрос, который найдет студентов, записанных хотя бы на один курс.**
    *   **q:** Составь список активных студентов — тех, кто записан минимум на один курс. Не нужно показывать, на какие именно, просто список уникальных студентов.
    *   **a:**
        *   **Кратко (через `JOIN`):** `SELECT DISTINCT students.* FROM students JOIN enrollments ON students.id = enrollments.student_id;`
        *   **Кратко (через подзапрос):** `SELECT * FROM students WHERE id IN (SELECT DISTINCT student_id FROM enrollments);`
        *   **Подробно:** Оба способа решают задачу.
            *   **Способ 1 (JOIN + DISTINCT):** Соединяем студентов с таблицей зачислений. Так как один студент может быть записан на несколько курсов, в результате соединения он появится несколько раз. `DISTINCT` убирает эти дубликаты, оставляя каждую запись о студенте в единственном экземпляре.
            *   **Способ 2 (Подзапрос с `IN`):** Подзапрос `(SELECT DISTINCT student_id FROM enrollments)` возвращает список уникальных ID студентов, которые есть в таблице `enrollments`. Внешний запрос выбирает из таблицы `students` только тех, чей `id` есть в этом списке.

22. **Используя вложенный запрос, найдите имена студентов, которые НЕ записаны ни на один курс.**
    *   **q:** Найди неактивных студентов — тех, кто еще не записался ни на один курс.
    *   **a:**
        *   **Кратко:** `SELECT name FROM students WHERE id NOT IN (SELECT DISTINCT student_id FROM enrollments);`
        *   **Подробно:** Это обратная задача предыдущей. Подзапрос `(SELECT DISTINCT student_id FROM enrollments)` дает нам список ID студентов, которые *записаны*. Внешний запрос выбирает имена из таблицы `students`, но с условием `NOT IN`, то есть исключая всех, кто попал в список из подзапроса.

23. **Напишите запрос, который выведет пары имен студентов, которые записаны на один и тот же курс.**
    *   **q:** Нужно найти всех "одногруппников" — студентов, которые учатся на одном и том же курсе. Выведи пары их имен.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT s1.name AS student1, s2.name AS student2, e1.course_id
            FROM enrollments e1
            JOIN enrollments e2 ON e1.course_id = e2.course_id AND e1.student_id < e2.student_id
            JOIN students s1 ON e1.student_id = s1.id
            JOIN students s2 ON e2.student_id = s2.id
            ORDER BY e1.course_id;
            ```
        *   **Подробно:** Это пример самообъединения (self-join) таблицы `enrollments`.
            1.  Мы берем таблицу `enrollments` дважды, с псевдонимами `e1` и `e2`.
            2.  Соединяем их по условию, что `course_id` совпадает. Так мы получаем комбинации всех записей об одном и том же курсе.
            3.  Добавляем условие `e1.student_id < e2.student_id`, чтобы исключить дублирующиеся пары (студент А с самим собой) и пары вида (студент2, студент1), если уже есть (студент1, студент2).
            4.  Затем присоединяем таблицу `students` дважды, чтобы получить имена для обоих ID.
        Результат покажет все возможные пары студентов на каждом курсе.

24. **Создайте запрос, который покажет название курса и количество студентов на нем, но только для тех курсов, где количество студентов больше 1.**
    *   **q:** Есть запрос, считающий популярность курсов. Модифицируй его так, чтобы он показывал только те курсы, на которые записано больше одного студента (то есть исключи курсы с 0 или 1 студентом).
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT courses.course_name, COUNT(enrollments.student_id) AS students_count
            FROM courses
            LEFT JOIN enrollments ON courses.id = enrollments.course_id
            GROUP BY courses.id, courses.course_name
            HAVING COUNT(enrollments.student_id) > 1;
            ```
        *   **Подробно:** Здесь ключевую роль играет оператор `HAVING`. Мы не можем использовать `WHERE` для фильтрации по результату агрегатной функции (`COUNT`), так как `WHERE` выполняется до `GROUP BY`. `HAVING` применяется уже после группировки и позволяет отфильтровать группы. Условие `HAVING COUNT(enrollments.student_id) > 1` оставляет только те группы (курсы), в которых количество студентов больше одного.

25. **В таблице `users` есть поле `grade`. Напишите запрос, который подсчитает количество пользователей для каждой оценки (grade).**
    *   **q:** В таблице `users` нужно провести анализ успеваемости: сгруппировать пользователей по их оценкам (`grade`) и посчитать, сколько человек получили каждую оценку.
    *   **a:**
        *   **Кратко:** `SELECT grade, COUNT(*) AS user_count FROM users GROUP BY grade;`
        *   **Подробно:** Классическое использование `GROUP BY`. Мы группируем все строки таблицы `users` по значениям столбца `grade`. Образуются группы: все строки с `grade='A'`, все с `grade='B'` и т.д. Для каждой такой группы мы с помощью `COUNT(*)` подсчитываем количество строк в ней. В результате получаем две колонки: саму оценку и количество пользователей с этой оценкой.

26. **Как с помощью `CREATE TABLE ... AS SELECT ...` создать новую таблицу `active_students`, которая будет содержать только студентов старше 25 лет из таблицы `users`?**
    *   **q:** Нужно создать отдельную небольшую таблицу для работы только со взрослыми студентами (старше 25), взяв данные из основной таблицы `users`.
    *   **a:**
        *   **Кратко:** `CREATE TABLE active_students AS SELECT * FROM users WHERE age > 25;`
        *   **Подробно:** Конструкция `CREATE TABLE ... AS SELECT ...` (в разных СУБД может называться `SELECT INTO` или иметь нюансы) позволяет создать новую таблицу и сразу наполнить её данными, полученными в результате `SELECT`-запроса. В данном случае мы создаем таблицу `active_students`, структура которой будет определена автоматически на основе выбранных столбцов, и копируем в нее все строки из `users`, которые подходят под условие `age > 25`. Это удобно для создания срезов данных или резервных копий.

27. **Напишите запрос, который выведет название курса и имя студента, используя `RIGHT JOIN`, чтобы гарантированно показать всех студентов, даже тех, кто не записан на курсы.**
    *   **q:** Задача, обратная задаче 13. Нужно показать всех студентов, и если они записаны на какие-то курсы, показать эти курсы.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT students.name, courses.course_name
            FROM students
            LEFT JOIN enrollments ON students.id = enrollments.student_id
            LEFT JOIN courses ON enrollments.course_id = courses.id;
            ```
        *   **Подробно:** Хотя в условии просят `RIGHT JOIN`, более естественно и читаемо здесь использовать `LEFT JOIN`, поменяв таблицы местами. Мы хотим видеть всех студентов, поэтому делаем таблицу `students` левой и дважды применяем `LEFT JOIN`. Если же использовать `RIGHT JOIN`, запрос будет выглядеть менее интуитивно, но даст тот же результат:
            ```sql
            SELECT students.name, courses.course_name
            FROM (enrollments
            RIGHT JOIN students ON enrollments.student_id = students.id)
            LEFT JOIN courses ON enrollments.course_id = courses.id;
            ```
            Здесь сначала `enrollments RIGHT JOIN students` гарантирует, что будут все студенты, а затем результат присоединяется к курсам.

28. **Используя оператор `CASE`, напишите запрос к таблице `users`, который выведет имя и возраст, а также текстовое поле 'status': 'Взрослый' для возраста >= 18, иначе 'Несовершеннолетний'.**
    *   **q:** Создай отчет по пользователям, где каждому будет присвоена категория в зависимости от возраста: взрослый или несовершеннолетний.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT name,
                   age,
                   CASE
                       WHEN age >= 18 THEN 'Взрослый'
                       ELSE 'Несовершеннолетний'
                   END AS status
            FROM users;
            ```
        *   **Подробно:** Оператор `CASE` работает как `if-else` в языках программирования. Он позволяет добавлять в результат вычисляемые столбцы. В данном случае мы проверяем значение `age` для каждой строки. Если условие `age >= 18` истинно, в новый столбец `status` записывается 'Взрослый'. В противном случае — 'Несовершеннолетний'.

29. **Напишите сложный запрос с объединением результатов: получите список всех имен студентов и отдельно список всех названий курсов.**
    *   **q:** Нужно получить единый вертикальный список, содержащий сначала все имена студентов, а затем все названия курсов.
    *   **a:**
        *   **Кратко:**
            ```sql
            SELECT name AS item, 'student' AS type FROM students
            UNION ALL
            SELECT course_name, 'course' FROM courses;
            ```
        *   **Подробно:** Здесь используется оператор `UNION ALL`. Он объединяет результаты двух (или более) запросов по вертикали. Первый запрос выбирает имена из таблицы `students`, второй — названия из `courses`. Чтобы различать, откуда пришла каждая строка, мы добавили второй столбец `type` с константой. `UNION ALL` (в отличие от `UNION`) не удаляет дубликаты, что здесь уместно, так как имя студента может совпасть с названием курса.

30. **Представьте, что при тестировании функционала регистрации вы отправили запрос через API, который должен создать нового пользователя. Какой SQL-запрос вы напишете, чтобы проверить, что пользователь действительно создан и все данные сохранились верно?**
    *   **q:** Ты тестируешь регистрацию. После отправки формы с данными (email: test@test.com, имя: TestUser) нужно убедиться, что пользователь появился в базе. Как это проверить?
    *   **a:**
        *   **Кратко:** `SELECT * FROM users WHERE email = 'test@test.com' AND name = 'TestUser';`
        *   **Подробно:** Как тестировщик, ты знаешь, какие данные отправил в запросе. Поэтому самый надежный способ проверить результат — выполнить поиск в базе данных по уникальному или комбинации неслучайных полей. Обычно это email, так как он уникален. Запрос вернет запись о новом пользователе, если она существует. Ты сможешь проверить, что все поля (`name`, `email`, возможно, хеш пароля, дата создания и т.д.) заполнены корректно и соответствуют ожиданиям.
